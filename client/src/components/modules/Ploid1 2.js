/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState, useEffect } from "react";
import { useGLTF, useAnimations, OrbitControls } from "@react-three/drei";
import { useControls } from "../three-utils";
import { useFrame, useThree, useStore } from "@react-three/fiber";
import { Vector3, Quaternion } from "three";

export default function Model(props) {
  const group = useRef();
  const { viewport } = useThree();
  const controls = useControls();
  const { nodes, materials, animations } = useGLTF("/ploid.glb");
  const { ref, actions, names } = useAnimations(animations, group);
  const [index, setIndex] = useState(0);

  // console.log("this is the camera",props.camera)

  // CONTROL KEYS
  let keysPressed = {};
  let walkVelocity = 2;
  let walkDirection = new Vector3();
  let rotateAngle = new Vector3(0, 1, 0);
  let rotateQuarternion = new Quaternion();
  let cameraTarget = new Vector3();
  // const keyDisplayQueue = new KeyDisplay();

  document.addEventListener(
    "keydown",
    (event) => {
      // keyDisplayQueue.down(event.key)
      // if (event.shiftKey && characterControls) {
      //     characterControls.switchRunToggle()
      // } else {
      keysPressed[event.key.toLowerCase()] = true;
      // }
    },
    false
  );
  document.addEventListener(
    "keyup",
    (event) => {
      // keyDisplayQueue.down(event.key)
      // if (event.shiftKey && characterControls) {
      //     characterControls.switchRunToggle()
      // } else {
      keysPressed = {};
      // }
    },
    false
  );

  // document.addEventListener('keyup', (event) => {
  //     keyDisplayQueue.up(event.key);
  //     (keysPressed as any)[event.key.toLowerCase()] = false
  // }, false);

//   useEffect(() => {
//     // Reset and fade in animation after an index has been changed
//     let animation = actions[names[index]];
//     animation.reset().fadeIn(0.5).play();
//     // In the clean-up phase, fade it out
//     return () => {
//       if (animation) {
//         animation.fadeOut(0.5);
//       }
//     };
//   }, [index, actions, names]);

//   let runVelocity = 5;

//   useFrame(({ clock }) => {
//     console.log("les see",keysPressed)
//     let camera = props.camera.current;

//     const { forward, backward, left, right, brake, reset } = controls.current;

//     if (keysPressed["w"] || keysPressed["a"] || keysPressed["d"] || keysPressed["s"]) {


//       var angleYCameraDirection = Math.atan2(
//         - camera.position.x + ref.current.position.x,
//         - camera.position.z + ref.current.position.z
//       );


//       // diagonal movement angle offset
//       var directionOffset = getDirectionOffset(keysPressed);

//       // rotate model
//       rotateQuarternion.setFromAxisAngle(rotateAngle,  angleYCameraDirection +directionOffset);


      
//       ref.current.quaternion.rotateTowards(rotateQuarternion, 0.1);
      
//       // if (keysPressed["a"] || keysPressed["d"]){

//         // camera.quaternion.rotateTowards(rotateQuarternion, 0.1);
//         // console.log()
//       // }

//       // calculate direction
//       camera.getWorldDirection(walkDirection);

//       // if (keysPressed["w"] || keysPressed["s"]) {

//         walkDirection.y = 0;
//         walkDirection.normalize();

//         walkDirection.applyAxisAngle(rotateAngle, directionOffset);

//         // // run/walk velocity
//         const velocity = 20;

//         const moveX = walkDirection.x * velocity * 0.01;
//         const moveZ = walkDirection.z * velocity * 0.01;

//         ref.current.position.x += moveX;
//         ref.current.position.z += moveZ;

//         camera.position.x += moveX;
//         camera.position.z += moveZ;

//         cameraTarget.x = ref.current.position.x;
//         cameraTarget.y = ref.current.position.y + 1;
//         cameraTarget.z = ref.current.position.z;
//         props.controls.current.target = cameraTarget;
//       // }
//     }
//   });

  return (
    <group ref={group} {...props} dispose={null}>
    <group
      name="CharacterArmature"
      position={[0, 0, 0]}
      rotation={[1.28, -0.07, 0.2]}>
      <primitive object={nodes.Root} />
      <skinnedMesh
        geometry={nodes.CUBezierCurve010.geometry}
        material={nodes.CUBezierCurve010.material}
        skeleton={nodes.CUBezierCurve010.skeleton}
      />
      <skinnedMesh
        geometry={nodes.CUBezierCurve010_1.geometry}
        material={nodes.CUBezierCurve010_1.material}
        skeleton={nodes.CUBezierCurve010_1.skeleton}
      />
      <skinnedMesh
        geometry={nodes.CUBezierCurve009.geometry}
        material={nodes.CUBezierCurve009.material}
        skeleton={nodes.CUBezierCurve009.skeleton}
      />
      <skinnedMesh
        geometry={nodes.CUBezierCurve009_1.geometry}
        material={nodes.CUBezierCurve009_1.material}
        skeleton={nodes.CUBezierCurve009_1.skeleton}
      />
      <skinnedMesh
        geometry={nodes.CUBezierCurve009_2.geometry}
        material={materials['Main2.002']}
        skeleton={nodes.CUBezierCurve009_2.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Ears.geometry}
        material={nodes.Ears.material}
        skeleton={nodes.Ears.skeleton}
      />
      <skinnedMesh
        geometry={nodes.CUBezierCurve008.geometry}
        material={nodes.CUBezierCurve008.material}
        skeleton={nodes.CUBezierCurve008.skeleton}
      />
      <skinnedMesh
        geometry={nodes.CUBezierCurve008_1.geometry}
        material={nodes.CUBezierCurve008_1.material}
        skeleton={nodes.CUBezierCurve008_1.skeleton}
      />
      <skinnedMesh
        geometry={nodes.CUBezierCurve008_2.geometry}
        material={materials['Black.002']}
        skeleton={nodes.CUBezierCurve008_2.skeleton}
      />
      <skinnedMesh
        geometry={nodes.CUBezierCurve008_3.geometry}
        material={materials['White.002']}
        skeleton={nodes.CUBezierCurve008_3.skeleton}
      />
      <skinnedMesh
        geometry={nodes.CUBezierCurve008_4.geometry}
        material={materials['EyeColor.002']}
        skeleton={nodes.CUBezierCurve008_4.skeleton}
      />
    </group>
  </group>
  );
}

function getDirectionOffset(keysPressed) {
  var directionOffset = 0; // w

  if (keysPressed["w"]) {
    if (keysPressed["a"]) {
      directionOffset = Math.PI / 4; // w+a
    } else if (keysPressed["d"]) {
      directionOffset = -Math.PI / 4; // w+d
    }
  } else if (keysPressed["s"]) {
    if (keysPressed["a"]) {
      directionOffset = Math.PI / 4 + Math.PI / 2; // s+a
    } else if (keysPressed["d"]) {
      directionOffset = -Math.PI / 4 - Math.PI / 2; // s+d
    } else {
      directionOffset = Math.PI; // s
    }
  } else if (keysPressed["a"]) {
    directionOffset = Math.PI / 2; // a
  } else if (keysPressed["d"]) {
    directionOffset = -Math.PI / 2; // d
  }

  return directionOffset;
}

useGLTF.preload("/ploid.glb");