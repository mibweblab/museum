/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState, useEffect } from "react";
import { useGLTF, useAnimations, OrbitControls } from "@react-three/drei";
import { useControls } from "../three-utils";
import { useFrame, useThree, useStore } from "@react-three/fiber";
import { Vector3, Quaternion } from "three";

export default function Model(props) {
  const group = useRef();
  const { viewport } = useThree();
  const controls = useControls();
  const { nodes, materials, animations } = useGLTF("/assets/ploid.glb");
  const { ref, actions, names } = useAnimations(animations, group);
  const [index, setIndex] = useState(0);

  // console.log("this is the camera",props.camera)

  // CONTROL KEYS
  let keysPressed = {};
  let walkVelocity = 2;
  let walkDirection = new Vector3();
  let rotateAngle = new Vector3(0, 1, 0);
  let rotateQuarternion = new Quaternion();
  let cameraTarget = new Vector3();
  // const keyDisplayQueue = new KeyDisplay();

  document.addEventListener(
    "keydown",
    (event) => {
      // keyDisplayQueue.down(event.key)
      // if (event.shiftKey && characterControls) {
      //     characterControls.switchRunToggle()
      // } else {
      keysPressed[event.key.toLowerCase()] = true;
      // }
    },
    false
  );
  document.addEventListener(
    "keyup",
    (event) => {
      // keyDisplayQueue.down(event.key)
      // if (event.shiftKey && characterControls) {
      //     characterControls.switchRunToggle()
      // } else {
      keysPressed = {};
      // }
    },
    false
  );

  // document.addEventListener('keyup', (event) => {
  //     keyDisplayQueue.up(event.key);
  //     (keysPressed as any)[event.key.toLowerCase()] = false
  // }, false);

  useEffect(() => {
    // Reset and fade in animation after an index has been changed
    let animation = actions[names[index]];
    animation.reset().fadeIn(0.5).play();
    // In the clean-up phase, fade it out
    return () => {
      if (animation) {
        animation.fadeOut(0.5);
      }
    };
  }, [index, actions, names]);

  let runVelocity = 5;

  useFrame(({ clock }) => {
    console.log("les see",keysPressed)
    let camera = props.camera.current;

    const { forward, backward, left, right, brake, reset } = controls.current;

    if (keysPressed["w"] || keysPressed["a"] || keysPressed["d"] || keysPressed["s"]) {


      var angleYCameraDirection = Math.atan2(
        - camera.position.x + ref.current.position.x,
        - camera.position.z + ref.current.position.z
      );


      // diagonal movement angle offset
      var directionOffset = getDirectionOffset(keysPressed);

      // rotate model
      rotateQuarternion.setFromAxisAngle(rotateAngle,  angleYCameraDirection +directionOffset);


      
      ref.current.quaternion.rotateTowards(rotateQuarternion, 0.1);
      
      // if (keysPressed["a"] || keysPressed["d"]){

        // camera.quaternion.rotateTowards(rotateQuarternion, 0.1);
        // console.log()
      // }

      // calculate direction
      camera.getWorldDirection(walkDirection);

      // if (keysPressed["w"] || keysPressed["s"]) {

        walkDirection.y = 0;
        walkDirection.normalize();

        walkDirection.applyAxisAngle(rotateAngle, directionOffset);

        // // run/walk velocity
        const velocity = 20;

        const moveX = walkDirection.x * velocity * 0.01;
        const moveZ = walkDirection.z * velocity * 0.01;

        ref.current.position.x += moveX;
        ref.current.position.z += moveZ;

        camera.position.x += moveX;
        camera.position.z += moveZ;

        cameraTarget.x = ref.current.position.x;
        cameraTarget.y = ref.current.position.y + 1;
        cameraTarget.z = ref.current.position.z;
        props.controls.current.target = cameraTarget;
      // }
    }
  });

  return (
    <group
      ref={group}
      {...props}
      dispose={null}
      // onClick={(e) => {e.stopPropagation(); console.log(props); (props.state.current = e.object.material.name)}}
    >
      <group name="CharacterArmature" position={[0, 0, 0]} rotation={[1.33, -0.02, -0.06]}>
        <primitive object={nodes.Root} />
        <skinnedMesh
          geometry={nodes.CUBezierCurve010.geometry}
          material={nodes.CUBezierCurve010.material}
          skeleton={nodes.CUBezierCurve010.skeleton}
          material-color={props.clothes}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve010_1.geometry}
          material={nodes.CUBezierCurve010_1.material}
          skeleton={nodes.CUBezierCurve010_1.skeleton}
          material-color={props.body}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve009.geometry}
          material={nodes.CUBezierCurve009.material}
          skeleton={nodes.CUBezierCurve009.skeleton}
          // material-color= "#FFA500"
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve009_1.geometry}
          material={nodes.CUBezierCurve009_1.material}
          skeleton={nodes.CUBezierCurve009_1.skeleton}
          // material-color= "#FFA500"
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve009_2.geometry}
          material={materials["Main2.002"]}
          skeleton={nodes.CUBezierCurve009_2.skeleton}
          material-color={props.chest}
        />
        <skinnedMesh
          geometry={nodes.Ears.geometry}
          material={nodes.Ears.material}
          skeleton={nodes.Ears.skeleton}
          //   material-color= "#FFA500"
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve008.geometry}
          material={nodes.CUBezierCurve008.material}
          skeleton={nodes.CUBezierCurve008.skeleton}
          //   material-color= "#FFA500"
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve008_1.geometry}
          material={nodes.CUBezierCurve008_1.material}
          skeleton={nodes.CUBezierCurve008_1.skeleton}
          //   material-color= "#FFA500"
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve008_2.geometry}
          material={materials["Black.002"]}
          skeleton={nodes.CUBezierCurve008_2.skeleton}
          //   material-color= "#FFA500"
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve008_3.geometry}
          material={materials["White.002"]}
          skeleton={nodes.CUBezierCurve008_3.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve008_4.geometry}
          material={materials["EyeColor.002"]}
          skeleton={nodes.CUBezierCurve008_4.skeleton}
          material-color={props.eyes}
        />
      </group>
    </group>
  );
}

function updateCameraTarget(camera, cameraTarget, ref, orbitControl, moveX, moveZ) {
  // move camera
  camera.position.x += moveX;
  camera.position.z += moveZ;

  // update camera target
  cameraTarget.x = ref.current.position.x;
  cameraTarget.y = ref.current.position.y + 1;
  cameraTarget.z = ref.current.position.z;
  orbitControl.target = cameraTarget;
}

// function getDirectionOffset({ forward, backward, left, right }) {
//   var directionOffset = 0; // w

//   if (backward) {
//     if (left) {
//       directionOffset = Math.PI / 4; // w+a
//     } else if (right) {
//       directionOffset = -Math.PI / 4; // w+d
//     }
//   } else if (forward) {
//     if (left) {
//       directionOffset = Math.PI / 4 + Math.PI / 2; // s+a
//     } else if (right) {
//       directionOffset = -Math.PI / 4 - Math.PI / 2; // s+d
//     } else {
//       directionOffset = Math.PI; // s
//     }
//   } else if (left) {
//     directionOffset = Math.PI / 2; // a
//   } else if (right) {
//     directionOffset = -Math.PI / 2; // d
//   }

//   return directionOffset;
// }

function getDirectionOffset(keysPressed) {
  var directionOffset = 0; // w

  if (keysPressed["w"]) {
    if (keysPressed["a"]) {
      directionOffset = Math.PI / 4; // w+a
    } else if (keysPressed["d"]) {
      directionOffset = -Math.PI / 4; // w+d
    }
  } else if (keysPressed["s"]) {
    if (keysPressed["a"]) {
      directionOffset = Math.PI / 4 + Math.PI / 2; // s+a
    } else if (keysPressed["d"]) {
      directionOffset = -Math.PI / 4 - Math.PI / 2; // s+d
    } else {
      directionOffset = Math.PI; // s
    }
  } else if (keysPressed["a"]) {
    directionOffset = Math.PI / 2; // a
  } else if (keysPressed["d"]) {
    directionOffset = -Math.PI / 2; // d
  }

  return directionOffset;
}

useGLTF.preload("/assets/ploid.glb");
