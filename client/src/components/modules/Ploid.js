/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import React, { useRef, useState, useEffect } from "react";
import { useGLTF, useAnimations, OrbitControls } from "@react-three/drei";
import { useControls } from "../three-utils";
import { useFrame, useThree, useStore } from "@react-three/fiber";
import { Vector3, Quaternion } from "three";
import { useBox } from "@react-three/cannon";

export default function Model(props) {
  const group = useRef();

  const { nodes, materials, animations } = useGLTF("/assets/new.glb");

  const [index, setIndex] = useState(1);

  const { ref, actions, names } = useAnimations(animations, group);

  // CONTROL KEYS
  let keysPressed = {};
  let walkDirection = new Vector3();
  let rotateAngle = new Vector3(0, 1, 0);
  let rotateQuarternion = new Quaternion();
  let cameraTarget = new Vector3();


  document.addEventListener(
    "keydown",
    (event) => {
      keysPressed[event.key.toLowerCase()] = true;
    },
    false
  );
  document.addEventListener(
    "keyup",
    (event) => {
      keysPressed = {};
    },
    false
  );

  useEffect(() => {
    // Reset and fade in animation after an index has been changed
    let animation = actions[names[index]];
    animation.reset().fadeIn(0.1).play();
    // In the clean-up phase, fade it out
    return () => {
      if (animation) {
        animation.fadeOut(0.1);
      }
    };
  }, [index, actions, names]);

  // let runVelocity = 5;

  useFrame(({ clock }) => {
    // console.log("les see",keysPressed)
    let camera = props.camera.current;

    // console.log("this is my camera",camera)

    // let play = 0;
    // if (keysPressed["w"] || keysPressed["a"] || keysPressed["d"] || keysPressed["s"]) {
    //   play = 1;
    // }

    // if (index !== play) {
    //   const toPlay = actions[names[play]];
    //   const current = actions[names[index]];
    //   current.fadeOut(0.2);
    //   toPlay.reset().fadeIn(0.2).play();
    //   setIndex(play);
    // }

    if (keysPressed["w"] || keysPressed["a"] || keysPressed["d"] || keysPressed["s"] || props.leftClick || props.rightClick || props.upClick || props.downClick) {

      var angleYCameraDirection = Math.atan2(
        -camera.position.x + ref.current.position.x,
        -camera.position.z + ref.current.position.z
      );

      // diagonal movement angle offset
      var directionOffset = getDirectionOffset(keysPressed,props.leftClick, props.rightClick, props.downClick, props.upClick);

      // rotate model
      rotateQuarternion.setFromAxisAngle(rotateAngle, angleYCameraDirection + directionOffset);

      ref.current.quaternion.rotateTowards(rotateQuarternion, 0.1);

      // if (keysPressed["a"] || keysPressed["d"]){

      // calculate direction
      camera.getWorldDirection(walkDirection);

      walkDirection.y = 0;
      walkDirection.normalize();

      walkDirection.applyAxisAngle(rotateAngle, directionOffset);

      // // run/walk velocity
      const velocity = 10;

      const moveX = walkDirection.x * velocity * 0.01;
      const moveZ = walkDirection.z * velocity * 0.01;

      ref.current.position.x += moveX;
      ref.current.position.z += moveZ;

      camera.position.x += moveX;
      camera.position.z += moveZ;

      cameraTarget.x = ref.current.position.x;
      cameraTarget.y = ref.current.position.y + 1;
      cameraTarget.z = ref.current.position.z;
      props.controls.current.target = cameraTarget;
      // console.log("camera target", cameraTarget)
    }
  });
  return (
    <group ref={ref} {...props} dispose={null}>
   
      <group name="idle"
      
      // position={[0, 0, 0]} rotation={[1.33, -0.02, -0.06]}
      >
        <primitive object={nodes.Root} />
        <skinnedMesh
          geometry={nodes.CUBezierCurve000.geometry}
          material={nodes.CUBezierCurve000.material}
          skeleton={nodes.CUBezierCurve000.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve000_1.geometry}
          material={nodes.CUBezierCurve000_1.material}
          skeleton={nodes.CUBezierCurve000_1.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve002.geometry}
          material={nodes.CUBezierCurve002.material}
          skeleton={nodes.CUBezierCurve002.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve002_1.geometry}
          material={nodes.CUBezierCurve002_1.material}
          skeleton={nodes.CUBezierCurve002_1.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve002_2.geometry}
          material={materials.Main2}
          skeleton={nodes.CUBezierCurve002_2.skeleton}
        />
        <skinnedMesh
          geometry={nodes.Ears.geometry}
          material={nodes.Ears.material}
          skeleton={nodes.Ears.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve003.geometry}
          material={nodes.CUBezierCurve003.material}
          skeleton={nodes.CUBezierCurve003.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve003_1.geometry}
          material={nodes.CUBezierCurve003_1.material}
          skeleton={nodes.CUBezierCurve003_1.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve003_2.geometry}
          material={materials.Black}
          skeleton={nodes.CUBezierCurve003_2.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve003_3.geometry}
          material={materials.White}
          skeleton={nodes.CUBezierCurve003_3.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve003_4.geometry}
          material={materials.EyeColor}
          skeleton={nodes.CUBezierCurve003_4.skeleton}
        />
      </group>
    </group>
  );
}

function getDirectionOffset(keysPressed, leftClick, rightClick, downClick, upClick) {

  var directionOffset = 0; // w

  if (keysPressed["w"] || upClick) {
    if (keysPressed["a"] || leftClick) {
      directionOffset = Math.PI / 4; // w+a
    } else if (keysPressed["d"] || rightClick) {
      directionOffset = -Math.PI / 4; // w+d
    }
  } else if (keysPressed["s"] || downClick) {
    if (keysPressed["a"] || leftClick) {
      directionOffset = Math.PI / 4 + Math.PI / 2; // s+a
    } else if (keysPressed["d"] || rightClick) {
      directionOffset = -Math.PI / 4 - Math.PI / 2; // s+d
    } else {
      directionOffset = Math.PI; // s
    }
  } else if (keysPressed["a"] || leftClick) {
    directionOffset = Math.PI / 2; // a
  } else if (keysPressed["d"] || rightClick) {
    directionOffset = -Math.PI / 2; // d
  }

  return directionOffset;
}

useGLTF.preload("/assets/new.glb");
