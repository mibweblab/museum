/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import React, { useRef, useState, useEffect } from "react";
import { useGLTF, useAnimations, OrbitControls } from "@react-three/drei";
import { useControls } from "../three-utils";
import { useFrame, useThree, useStore } from "@react-three/fiber";
import { Vector3, Quaternion } from "three";
import { useBox } from "@react-three/cannon";

export default function Model(props) {
  const group = useRef();

  // const [group, api] = useBox(
  //   () => ({
  //     // mass:10,
  //     // position:[0,0,0],
  //     // rotation:[0, 0, 0],
  //     // args,
  //     allowSleep: false,
  //     // onCollide: (e) => console.log("bonk", e.body.userData),
  //     ...props,
  //   }),
  //   group
  // );

  const { nodes, materials, animations } = useGLTF("/assets/new.glb");

  const [index, setIndex] = useState(1);

  const { ref, actions, names } = useAnimations(animations, group);

  // CONTROL KEYS
  let keysPressed = {};
  let walkVelocity = 2;
  let walkDirection = new Vector3();
  let rotateAngle = new Vector3(0, 1, 0);
  let rotateQuarternion = new Quaternion();
  let cameraTarget = new Vector3();
  // const keyDisplayQueue = new KeyDisplay();

  document.addEventListener(
    "keydown",
    (event) => {
      keysPressed[event.key.toLowerCase()] = true;
    },
    false
  );
  document.addEventListener(
    "keyup",
    (event) => {
      keysPressed = {};
    },
    false
  );

  useEffect(() => {
    // Reset and fade in animation after an index has been changed
    let animation = actions[names[index]];
    animation.reset().fadeIn(0.1).play();
    // In the clean-up phase, fade it out
    return () => {
      if (animation) {
        animation.fadeOut(0.1);
      }
    };
  }, [index, actions, names]);

  // let runVelocity = 5;

  useFrame(({ clock }) => {
    // console.log("les see",keysPressed)
    let camera = props.camera.current;

    // let play = 0;
    // if (keysPressed["w"] || keysPressed["a"] || keysPressed["d"] || keysPressed["s"]) {
    //   play = 1;
    // }

    // if (index !== play) {
    //   const toPlay = actions[names[play]];
    //   const current = actions[names[index]];
    //   current.fadeOut(0.2);
    //   toPlay.reset().fadeIn(0.2).play();
    //   setIndex(play);
    // }

    if (keysPressed["w"] || keysPressed["a"] || keysPressed["d"] || keysPressed["s"]) {
      var angleYCameraDirection = Math.atan2(
        -camera.position.x + ref.current.position.x,
        -camera.position.z + ref.current.position.z
      );

      // diagonal movement angle offset
      var directionOffset = getDirectionOffset(keysPressed);

      // rotate model
      rotateQuarternion.setFromAxisAngle(rotateAngle, angleYCameraDirection + directionOffset);

      ref.current.quaternion.rotateTowards(rotateQuarternion, 0.1);

      // if (keysPressed["a"] || keysPressed["d"]){

      // calculate direction
      camera.getWorldDirection(walkDirection);

      walkDirection.y = 0;
      walkDirection.normalize();

      walkDirection.applyAxisAngle(rotateAngle, directionOffset);

      // // run/walk velocity
      const velocity = 2;

      const moveX = walkDirection.x * velocity * 0.01;
      const moveZ = walkDirection.z * velocity * 0.01;

      ref.current.position.x += moveX;
      ref.current.position.z += moveZ;

      camera.position.x += moveX;
      camera.position.z += moveZ;

      cameraTarget.x = ref.current.position.x;
      cameraTarget.y = ref.current.position.y + 1;
      cameraTarget.z = ref.current.position.z;
      props.controls.current.target = cameraTarget;
    }
  });
  return (
    <group ref={ref} {...props} dispose={null}>
   
      <group name="idle"
      
      // position={[0, 0, 0]} rotation={[1.33, -0.02, -0.06]}
      >
        <primitive object={nodes.Root} />
        <skinnedMesh
          geometry={nodes.CUBezierCurve000.geometry}
          material={nodes.CUBezierCurve000.material}
          skeleton={nodes.CUBezierCurve000.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve000_1.geometry}
          material={nodes.CUBezierCurve000_1.material}
          skeleton={nodes.CUBezierCurve000_1.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve002.geometry}
          material={nodes.CUBezierCurve002.material}
          skeleton={nodes.CUBezierCurve002.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve002_1.geometry}
          material={nodes.CUBezierCurve002_1.material}
          skeleton={nodes.CUBezierCurve002_1.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve002_2.geometry}
          material={materials.Main2}
          skeleton={nodes.CUBezierCurve002_2.skeleton}
        />
        <skinnedMesh
          geometry={nodes.Ears.geometry}
          material={nodes.Ears.material}
          skeleton={nodes.Ears.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve003.geometry}
          material={nodes.CUBezierCurve003.material}
          skeleton={nodes.CUBezierCurve003.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve003_1.geometry}
          material={nodes.CUBezierCurve003_1.material}
          skeleton={nodes.CUBezierCurve003_1.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve003_2.geometry}
          material={materials.Black}
          skeleton={nodes.CUBezierCurve003_2.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve003_3.geometry}
          material={materials.White}
          skeleton={nodes.CUBezierCurve003_3.skeleton}
        />
        <skinnedMesh
          geometry={nodes.CUBezierCurve003_4.geometry}
          material={materials.EyeColor}
          skeleton={nodes.CUBezierCurve003_4.skeleton}
        />
      </group>
    </group>
  );
}

function getDirectionOffset(keysPressed) {
  var directionOffset = 0; // w

  if (keysPressed["w"]) {
    if (keysPressed["a"]) {
      directionOffset = Math.PI / 4; // w+a
    } else if (keysPressed["d"]) {
      directionOffset = -Math.PI / 4; // w+d
    }
  } else if (keysPressed["s"]) {
    if (keysPressed["a"]) {
      directionOffset = Math.PI / 4 + Math.PI / 2; // s+a
    } else if (keysPressed["d"]) {
      directionOffset = -Math.PI / 4 - Math.PI / 2; // s+d
    } else {
      directionOffset = Math.PI; // s
    }
  } else if (keysPressed["a"]) {
    directionOffset = Math.PI / 2; // a
  } else if (keysPressed["d"]) {
    directionOffset = -Math.PI / 2; // d
  }

  return directionOffset;
}

useGLTF.preload("/assets/new.glb");
